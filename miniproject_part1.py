# -*- coding: utf-8 -*-
"""miniproject_part1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mQ1G-Cr-2ZLT4FhM6-zbf-LkKisC25cl

# **Part 1**

## Setup

We start by confirming our runtime has access to a GPU (if not, correct this using Runtime -> Change Runtime Type) and installing mumax3.
"""

! echo "This machine runs" $(uname)
! echo
! nvidia-smi

# Download the mumax3 binary
!wget https://mumax.ugent.be/mumax3-binaries/mumax3.10_linux_cuda10.1.tar.gz
!tar -xvf mumax3.10_linux_cuda10.1.tar.gz
!rm mumax3.10_linux_cuda10.1.tar.gz
!rm -rf mumax3.10 && mv mumax3.10_linux_cuda10.1 mumax3.10

#update the PATH environment variable
import os
os.environ['PATH'] += ":/content/mumax3.10"

"""## Simulation

In this simulation, we will simulate the response of an ellipsoidal magnetite (iron (II,III) oxide) particle to an external magnetic field which we will ramp from 0 to +100 mT, then down to -100 mT, then back up to +100 mT.

We will assume that the field is ramped up and down sufficiently slowly that the magnetite particle remains in equilbirum with the field. In this case, it is more efficient to use Mumax3's minimize() function for each field step (treating the change in field from the previous step as a perturbation) to see how the magnetisation changes.

For our initial magnetisation we will set each micromagnetic cell to have a random magnetisation direction and use the relax() function to find a stable starting configuration. Note that if the applied field becomes large enough to saturate the magnetisation, then we have effectively erased the history of the particle prior to the field loop so the exact starting state is not too important.
"""

!mumax3 magnetiteParticle.mx3

"""As before, we will generate some images to see how the magnetisation evolves."""

!mumax3-convert -png -arrows 10 magnetiteParticle.out/*.ovf

from IPython.display import display, Image
import os

# Generate a list of all PNG files in the MuMax output folder magnetiteParticle.out
folder = 'magnetiteParticle.out'
path = os.path.join(os.getcwd(), folder)
files = [f for f in os.listdir(path) if f.endswith('.png')]
files.sort()

# Display the PNG files
for f in files:
    print(f)
    display(Image(filename=os.path.join(path, f)))

"""## Postprocessing

Complete the code block below to plot the magnetisation along the long axis of 
the ellipsoid as a function of the applied field along this axis to determine the coercive field.

How does this compare with the value of $H_c$ predicted by the Stoner Wohlfarth model?
"""

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Sat Mar 18 15:32:03 2023

@author: kristinnpetursson
Project: Mini-Project "Micromagnetics"
Module: MATE70002 - Theory and Simulation
Date: 19 March, 2023
"""
import numpy as np
import pandas as pd
from matplotlib import pyplot as plt
from shapely.geometry import LineString
from math import sqrt

# Function: intersectionXCoordinance - finding the x coordinance by interpolating
# arrayX: an array of values that are plotten on x axis
# arrayY: an array of values that are plotted on y axis
# valueYClosest0: a float, closest value of arrayY to 0
# return: the x-coordinance of the intersection between x- axis (y=0) and hysterisis
def intersectionXCoordinance(arrayX, arrayY , indexYClosest0):
    valueY1 = float(arrayY[indexYClosest0])
    valueX1 = float(arrayX[indexYClosest0])
    indexNext = indexYClosest0 +1 
    indexPrevious = indexYClosest0 - 1
    valueY2 = 0
    valueX2 = 0
    #4 possibilities, ++, --, +-, -+
    if((arrayY[indexNext] > 0) & (valueY1 > 0)):
        #find value of the previous
        #print("both higher than 0")
        valueY2 = float(arrayY[indexNext])
        valueX2 = float(arrayX[indexNext])
        return interpolating(valueX1, valueX2, valueY1, valueY2)
    
    elif((arrayY[indexNext] < 0) & (valueY1 < 0)):
        #find value of the next
        #print("both lower than 0")
        valueY2 = float(arrayY[indexPrevious])
        valueX2 = float(arrayX[indexPrevious])
        return interpolating(valueX1, valueX2, valueY1, valueY2)
    
    elif( (arrayY[indexNext] <  valueY1) or (arrayY[indexNext] >  valueY1) ): 
        #downward trending or upwards
        valueY2 = float(arrayY[indexNext])
        valueX2 = float(arrayX[indexNext])
        return interpolating(valueX1, valueX2, valueY2, valueY1)
        
    else: #upward trending
       return print("problem with data")    

#function: interpolating
# return: the x value of interseption
def interpolating(x1, x2, y1, y2):
    result =  np.around( float(x1) - y1*(x2-x1)/(y2-y1), 4)
    print(result)
    return result

folder = "magnetiteParticle.out"
data = np.loadtxt('magnetiteParticle.out/micro/table.txt',skiprows=1)

mx = np.array( [d[1] for d in data] )
my = np.array([d[2] for d in data] )
mtotal = np.around(( (sqrt(2)/2)*mx + (sqrt(2)/2)*my) , 4)

Bextx = np.array([d[4] for d in data])
Bexty = np.array([d[5] for d in data] )
Btotal = np.around(((sqrt(2)/2)*Bextx + (sqrt(2)/2)*Bexty), 4)

#Delete beginning of graph when system is "ramping" up
index = np.argmax(mtotal > 0.55)
m_newTotal = mtotal[index:-1]
b_newTotal = 100*Btotal[index:-1]

#find intersections
closestToZero1 = np.abs(m_newTotal - 0).argmin()
x1 = intersectionXCoordinance(b_newTotal, m_newTotal, closestToZero1)
#Fnding lowest value second intersection with 0
sizeArray = int(2*len(m_newTotal)/3) #the last third part  of array.
newArrayB = b_newTotal[sizeArray:-1]
newArrayM = m_newTotal[sizeArray:-1]
closestZero2 = np.abs(newArrayM - 0).argmin() #closest value to 0
x2 = intersectionXCoordinance(newArrayB, newArrayM, closestZero2)


#Intersection of m_sat and hysterisis
closestToSat = np.abs(b_newTotal - 0).argmin()
y3 = m_newTotal[closestToSat]

#plotting
plt.axvline(x=x2, color='gray', linestyle='--')
plt.axhline(y=0, color='gray', linestyle='--')
plt.axvline(x=0, color='red', linestyle='--')
plt.axhline(y=y3, color='red', linestyle='--')
plt.plot(b_newTotal ,m_newTotal)

#display text on plot
stringX1 = '\u03BC' + '\u2080' + '$H_C$ = ' + str(x1) + ' mT'
stringX2 = '\u03BC' + '\u2080' + '$H_C$ = ' + str(x2) + ' mT'
stringX3 = '$m_r / m_{sat}$ = ' + str(y3)
plt.text(-10.5, 0.10, stringX1, color='black')
plt.text(4.75, 0.10, stringX2 , color='black')
plt.text(-6.0, 0.8, stringX3, color='red')
#labels and showing plot
plt.xlabel('$\u03bc_0H$ (mT)', size=18)
plt.ylabel('$m / m_{sat} (mT)$', size=18)
plt.ylim(-1,1)
plt.show()

